#!/usr/bin/perl

(my $SCRIPT = $0) =~ s/^.*\///;
use strict;
use warnings;
use Cwd           qw/cwd/;       # core
use POSIX         qw/strftime/;  # core
use Data::Dumper;                # core
use Getopt::Long;                # core
use Archive::Tar;                # core

# {{{ use JSON

my $SRC;
sub _s
{
	my ($i, $s, $a, $b, $l) = (0, "", "", "", length($SRC));

	$b = substr($SRC, $i++, 1);
	if ($b ne '"') {
		while ($i < $l) {
			$a = $b; $b = substr($SRC, $i++, 1);
			if ($a eq '\\') {
				$s .= $b; $a = $b = '';
			} else {
				$s .= $a;
				if ($b eq '"') { $b = ''; last; }
			}
		}
		$s .= $b;
	}
	$SRC = substr($SRC, $i);
	$s;
}
sub _lex
{
	$SRC =~ s/^\s+//;
	return undef unless $SRC;

	return     $1  if $SRC =~ s/^([{}\[\],:])//;
	return [   $1] if $SRC =~ s/^([+-]?[0-9]+(?:\.[0-9]+)?(?:e[+-]?\d+)?)//;
	return [    1] if $SRC =~ s/^true\b//;
	return [    0] if $SRC =~ s/^false\b//;
	return [undef] if $SRC =~ s/^null\b//;
	return [ _s()] if $SRC =~ s/^"//;
	die "Malformed JSON at ".substr($SRC, 0, 140)."\n";
}

sub _decode_hash
{
	my $h = {};
	while (my $t = _lex()) {
		unless (ref $t) {
			next      if $t eq ',';
			return $h if $t eq '}';
			die "Invalid '$t' in hash!\n";
		}
		my $key = $t->[0];

		$t = _lex() or last;
		die "Missing ':' key/value separator!\n" unless $t eq ':';

		$t = _lex() or last;
		if (ref $t)       { $h->{$key} = $t->[0] }
		elsif ($t eq '{') { $h->{$key} = _decode_hash() }
		elsif ($t eq '[') { $h->{$key} = _decode_list() }
		else { die "Unexpected $t after ':' key/value separator!\n" }
	}
	die "Unexpected end of input string\n";
}

sub _decode_list
{
	my $l = [];
	while (my $t = _lex()) {
		unless (ref $t) {
			next      if $t eq ',';
			return $l if $t eq ']';
		}

		if (ref $t)       { push @$l, $t->[0] }
		elsif ($t eq '{') { push @$l, _decode_hash() }
		elsif ($t eq '[') { push @$l, _decode_list() }
		else { die "Unexpected $t in list!\n" }
	}
	die "Unexpected end of input string\n";
}

sub decode_json
{
	$SRC = $_[0];
	my $t = _lex();
	die "Unexpected end of input string\n" if !!! $t;
	die "Invalid literal at top-level!\n"  if ref $t;

	return _decode_hash() if $t eq '{';
	return _decode_list() if $t eq '[';

	die "Invalid '$t' at top-level!\n";
}
# }}}
# {{{ ANSI coloring
my %C = (
	x      => "\x1b[0m",
	black  => "\x1b[30;0m",
	red    => "\x1b[31m",
	green  => "\x1b[32m",
	yellow => "\x1b[33m",
	blue   => "\x1b[34m",
	purple => "\x1b[35m",
	cyan   => "\x1b[36m",
	white  => "\x1b[37m",
);
unless (-t STDOUT) {
	$C{$_} = '' for keys %C;
}
# }}}
# {{{ Options Processing

sub usage
{
	print "USAGE: $SCRIPT  OPTIONS  COMMAND  [MODULE [MODULE ...]]\n";
	return 0;
}

my %OPTIONS = (
	root      => cwd,
	template  => undef,
	tests     => 1,
	prefix    => 'perl',
	overrides => '/etc/cpanimal/overides.conf',
	debug     => $ENV{DEBUG},
);
sub debug
{
	print "$C{purple}+++ $_[0]$C{x}\n" if $OPTIONS{debug};
}
sub rcfiles
{
	for my $file (@_) {
		debug "trying rc file $file";
		next unless -f $file;
		debug "parsing rc file $file";
		open my $fh, "<", $file or die "Failed to open $file: $!\n";
		while (<$fh>) {
			chomp;
			s/\s*#.*//;
			next unless m/^(\S+)\s+(.*)/;
			if (exists $OPTIONS{$1}) {
				$OPTIONS{$1} = $2;
				next;
			}
			warn "Ignoring unknown configuration option '$1'\n";
		}
		close $fh;
	}
}
rcfiles("$ENV{HOME}/.cpanimalrc", "/etc/cpanimal/cpanimalrc");
$OPTIONS{root} =~ s!^~/!$ENV{HOME}/!;
GetOptions(\%OPTIONS, qw/
	help|h|?
	debug|D

	prefix=s
	root=s
	tests!
	overrides=s
/) or exit usage();

sub read_DATA
{
	my (@blocks, @s);
	while (<DATA>) {
		if (m/^__DATA__$/ and @s) {
			push @blocks, join('', @s);
			@s = ();
		} else {
			push @s, $_;
		}
	}
	close DATA;
	return @blocks;
}

my ($embedded_SPEC, $PERL_PROVIDES) = read_DATA;
my $SPEC;
if (defined $OPTIONS{template}) {
	open my $tpl, "<", $OPTIONS{template}
		or die "$OPTIONS{template}: $!\n";
	$SPEC = do { local $/; <$tpl> };
	close $tpl;
} else {
	$SPEC = $embedded_SPEC;
	$OPTIONS{template} = '<embedded>';
}

my $PWD = cwd;
my $SUDO = ($< == 0 ? '' : 'sudo ');
my %SEEN = ();
my %HAVE = ( perl => 1 );

# }}}
# {{{ Helper utilities
sub bail
{
	my ($msg, @rest) = @_;
	die $msg."\n".Dumper(@rest) if $ENV{DEBUG};
	die $msg."\n(re-run with DEBUG=1 in your environment for diagnostics)\n";
}

sub run
{
	my ($command) = @_;
	print "$C{yellow}+ $command$C{x}\n";
	qx($command);
}

sub runlog
{
	my ($command) = @_;
	print "$C{yellow}+ $command$C{x}\n";
	qx($command >$OPTIONS{root}/.lastlog 2>&1);
	dump_log('black') if $OPTIONS{debug};
}

my $QUIET = 0;
sub stage
{
	print "$C{cyan}####   $_[0]   ####$C{x}\n" unless $QUIET;
}

sub step
{
	print "$C{green}>> $_[0]$C{x}\n" unless $QUIET;
}

sub lookup
{
	my ($name) = @_;
	if (-f "$OPTIONS{root}/.cache/$name") {
		open my $fh, "<", "$OPTIONS{root}/.cache/$name";
		if ($fh) {
			my $v = decode_json(do { local $/; <$fh> });
			close $fh;
			return $v;
		}
		warn "Failed to open cache file: $OPTIONS{root}/.cache/$name; contactin API\n";
	}

	my $url = "http://api.metacpan.org";

	step "retrieving $url/module/$name";
	my $json = qx(curl -q $url/module/$name 2>/dev/null);
	$? == 0 or return undef;

	my $module = decode_json($json);
	$module->{message} and die "error: $module->{message}\n";
	$module->{distribution}
		or bail "No distribution found in module metadata!\n".
		        "Either this module is corrupt, or $SCRIPT needs some TLC...\n", $module;

	step "retrieving $url/release/$module->{distribution}";
	$json = qx(curl -q $url/release/$module->{distribution} 2>/dev/null);
	$? == 0 or return undef;

	if (-d "$OPTIONS{root}/.cache") {
		open my $fh, ">", "$OPTIONS{root}/.cache/$name";
		if ($fh) {
			print $fh $json;
			close $fh;
		} else {
			warn "Unable to open cache file $OPTIONS{root}/.cache/$name for writing: $!\n";
		}
	}
	my $rel = decode_json($json);
	$rel->{message} and die "error: $rel->{message}\n";
	$rel->{distribution}
		or bail "No distribution found in release metadata!\n".
		        "Either this module is corrupt, or $SCRIPT needs some TLC...\n", $rel;
	$rel;
}

sub deps
{
	my ($rel) = @_;

	my (@requires, @build_requires);
	for my $dep (@{ $rel->{dependency} }) {
		next if $dep->{phase}        eq 'develop';
		next if $dep->{phase}        eq 'test' and !$OPTIONS{tests};
		next if $dep->{relationship} ne 'requires';

		if ($dep->{phase} =~ m/^(configure|test|build)/) {
			push @build_requires, $dep;
		} else {
			push @requires,       $dep;
		}
	}

	return \@requires, \@build_requires;
}

sub req_name
{
	my ($mod, $ver) = @_;
	$mod = "perl($mod)" unless $mod eq 'perl';
	$ver ? "$mod >= $ver" : $mod;
}

sub reqs
{
	my ($tag, $list) = @_;
	if (!$list) {
		$list = $tag;
		$tag = '';
	}
	join('', map {
		sprintf("%-15s %s\n", "${tag}Requires:",
			req_name($_->{module}, $_->{version}))
	} @$list);
}

chomp(my $ARCH = qx(uname -m));
sub module_arch
{
	my ($archive) = @_;
	my $tar = Archive::Tar->new;
	$tar->read($archive);

	for ($tar->list_files()) {
		return $ARCH if m/\.(xs|c|cpp)$/;
	}
	return 'noarch';
}

sub archive_root_dir
{
	my ($archive, @try) = @_;
	my $tar = Archive::Tar->new;
	$tar->read($archive);

	debug "determining dist archive root directory...";
	for (@try) {
		debug "trying $_";
		return $_ if $tar->contains_file("$_/") # trailing slash
		          or $tar->contains_file("$_"); # is optional
	}
	debug "is it one of these?";
	debug "  $_" for grep { !m{/.+/} } $tar->list_files;
	die "Unable to determine root directory for $try[0] archive $archive\n";
}

sub specfile
{
	my ($file, $rel, $requires, $build_requires) = @_;
	open my $spec, ">", $file
		or die "Failed to open $file for writing: $!\n";

	my $url = $rel->{download_url};
	(my $tarball = $url) =~ s!.*/!!;
	if (!-f "$OPTIONS{root}/SOURCES/$tarball") {
		step "downloading $url";
		run qq(curl $url > $OPTIONS{root}/SOURCES/$tarball);
		$? == 0 or die "Failed.\n";
	} else {
		step "using pre-existing $tarball";
	}
	my $arch = module_arch("$OPTIONS{root}/SOURCES/$tarball");

	my $PREFIX = $OPTIONS{prefix};
	$PREFIX = "$PREFIX-" unless $PREFIX =~ m/-$/;
	$PREFIX = '' if $rel->{distribution} eq 'mod_perl';

	my $relname = $rel->{name};
	my $version = $relname; $version =~ s/.*-//;
	my $archive_root = archive_root_dir("$OPTIONS{root}/SOURCES/$tarball",
		$relname, $rel->{distribution});

	my $overrides = parse_overrides_files(
		$OPTIONS{overrides},
		'/etc/cpanimal/overrides.conf',
		"$ENV{HOME}/.cpanimal.overrides");

	my %tokens = (
		VERSION        => $version,
		DISTNAME       => $rel->{distribution},
		SOURCE         => $relname.'.tar.gz',
		RPMPREFIX      => $PREFIX,
		RPMFILE        => $PREFIX.$relname."-1.$arch.rpm",
		SUMMARY        => $rel->{abstract},
		DESCRIPTION    => $rel->{abstract},
		URL            => $rel->{download_url},
		PACKAGER_NAME  => $ENV{PACKAGER_NAME}  ||  $ENV{USER}                  || '(nobody)',
		PACKAGER_EMAIL => $ENV{PACKAGER_EMAIL} || "$ENV{USER}\@$ENV{HOSTNAME}" || 'none',
		DATE           => strftime("%a %b %d %Y", localtime(time)),
		REQUIRES       => reqs($requires),
		BUILDREQUIRES  => reqs('Build', $build_requires),
		BUILDARCH      => $arch,
		ARCHIVE_ROOT   => $archive_root,
		RUN_TESTS      => $OPTIONS{tests},

		PATCHED_PERL_PROVIDES => $PERL_PROVIDES,

		OVERRIDE_ADD_REQUIRES      => override_adds($rel->{distribution},
			'requires', $overrides),
		OVERRIDE_ADD_BUILDREQUIRES => override_adds($rel->{distribution},
			'build_requires', $overrides),

		OVERRIDE_SKIP_FILES => override_skip_files($rel->{distribution},
			$overrides),
		OVERRIDE_SKIP_REQUIRES => override_skips($rel->{distribution},
			'requires', $overrides),
		OVERRIDE_SKIP_PROVIDES => override_skips($rel->{distribution},
			'provides', $overrides),
	);
	$tokens{URL} =~ s/$tokens{VERSION}\.tar\.gz$/%{version}.tar.gz/g;
	my $x = "$SPEC";
	$x =~ s/\{\{$_\}\}/$tokens{$_}/eg for keys %tokens;
	print $spec $x;
	close $spec;

	return %tokens;
}

sub dump_log
{
	open my $log, "<", "$OPTIONS{root}/.lastlog"
		or return;
	my $contents = do { local $/; <$log> };
	close $log;

	if ($contents) {
		print $C{$_[0] || 'red'}; print "-" x 80; print "\n";
		print $contents;
		print "-" x 80; print "\n"; print $C{x};
	}

	if ($OPTIONS{debug}) {
		print $C{$_[0] || 'red'};
		print "  Module state dump:\n";
		print "  - have '$_'\n" for sort keys %HAVE;
		print $C{x};
	}
}

sub check_log
{
	my ($re) = @_;
	open my $fh, "<", "$OPTIONS{root}/.lastlog" or return undef;
	while (local $_ = <$fh>) {
		next unless m/$re/;
		close $fh; return 1;
	}
	close $fh; return undef;
}

sub grep_log
{
	my ($re) = @_;
	my @l;
	open my $fh, "<", "$OPTIONS{root}/.lastlog" or return;
	while (<$fh>) {
		push @l, $1 if m/$re/;
	}
	close $fh;
	return @l;
}

sub have_module
{
	my ($mod, $ver) = @_;
	return 1 if $HAVE{$mod};    # FIXME: handle version deps

	if ($mod ne 'Module::Runtime' and have_module('Module::Runtime')) {
		runlog qq|perl -MModule::Runtime=use_module -e 'use_module("$mod");'|;
	} else {
		runlog qq|perl -M$mod -e 'exit 0;'|;
	}
	return ($HAVE{$mod} = ($? == 0));
}

sub setup
{
	qx(mkdir -p $OPTIONS{root});
	qx(mkdir -p $OPTIONS{root}/$_)
		for qw/ RPMS SRPMS SOURCES SPECS BUILD .cache /
}

# }}}
# {{{ Overrides handling

sub parse_overrides_files
{
	for (@_) {
		return parse_overrides_file($_) if -f $_;
	}
}

sub parse_overrides_file
{
	my ($path) = @_;
	open my $fh, "<", $path
		or return {};
	my $over = parse_overrides_io($fh);
	close $fh;
	$over;
}

sub parse_overrides_io
{
	my ($io) = @_;
	my @lines;
	while (<$io>) {
		chomp;
		s/\s*#.*$//;
		s/;/ ; /g;
		push @lines, $_;
	}

	my %over;
	my @tokens = grep { length $_ } split(/\s+/, join(' ', @lines));
	while (@tokens) {
		my $pkg    = shift @tokens or die "Unexpected end of input\n";
		next if $pkg eq ';'; # allow multiple semi-colons
		my $action = shift @tokens or die "Unexpected end of input\n";
		my $key    = shift @tokens or die "Unexpected end of input\n";
		my @values;
		while (@tokens) {
			my $t = shift @tokens;
			last if $t eq ';';
			push @values, $t;
		}
		@values or die "Unexpected end of input\n";

		$action =~ m/^(skip|add)$/
			or die "Unrecognized action '$action'\n(you want 'skip' or 'add')\n";
		$key =~ m/^(build_requires|requires|provides|files)$/
			or die "Unrecognized key '$key'\n(you want 'requires', 'build_requires', 'provides' or 'files')\n";

		die "'add files' is not supported at this time.\n"
			if $action eq 'add' and $key eq 'files';

		$over{$pkg}{$action}{$key} ||= [];
		push @{ $over{$pkg}{$action}{$key} }, @values;
	}
	return \%over;
}

sub override_skip_files
{
	my ($dist, $overrides) = @_;
	my @l;
	for my $top ('*', $dist) {
		next unless exists $overrides->{$top}{skip}{files};

		for my $skip (@{ $overrides->{$top}{skip}{files} }) {
			if ($skip =~ m{^/(.*)/$}) {
				push @l, "find \$RPM_BUILD_ROOT -regextype posix-extended -regex '.*$1.*' -exec rm -f {} \\;";
			} else {
				push @l, "find \$RPM_BUILD_ROOT -path $skip -exec rm -f {} \\;";
			}
		}
	}
	join("\n", @l);
}

sub override_skips
{
	my ($dist, $type, $overrides) = @_;
	my @l;
	for my $top ('*', $dist) {
		next unless exists $overrides->{$top}{skip}{$type};

		for my $skip (@{ $overrides->{$top}{skip}{$type} }) {
			if ($skip =~ m{^/.*/$}) {
				push @l, "  sed -e '${skip}d' |\\";
			} else {
				push @l, "  sed -e '/^$skip\$/d' |\\";
			}
		}
	}
	join("\n", @l);
}

sub override_adds
{
	my ($dist, $type, $overrides) = @_;
	my @l;
	my $tag = "# unknown type '$type': ";
	if ($type eq 'requires')       { $tag = 'Requires: ' }
	if ($type eq 'build_requires') { $tag = 'BuildRequires: ' }
	if ($type eq 'provides')       { $tag = 'Provides: ' }

	for my $top ('*', $dist) {
		next unless exists $overrides->{$top}{add}{$type};

		push @l, "$tag$_\n" for @{ $overrides->{$top}{add}{$type} };
	}
	join('', @l);
}

# }}}

sub spec
{
	my ($name) = @_;
	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";
	my $dist = $rel->{distribution};
	my ($requires ,$build_requires) = deps($rel);

	my $specfile = "$OPTIONS{root}/SPECS/$dist.spec";
	specfile($specfile, $rel, $requires, $build_requires);
	step "wrote spec file for $name to $specfile";
}

sub source
{
	my ($name) = @_;
	stage "Getting source for $name";
	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";
	my $dist = $rel->{distribution};

	my $url = $rel->{download_url};
	(my $file = $url) =~ s!.*/!!;
	step "downloading $url";
	run qq(curl $url > $OPTIONS{root}/SOURCES/$file);
	print "\n";
	$? == 0 or die "Failed.\n";
}

sub info
{
	my ($name) = @_;
	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";

	print <<EOF;
============================== $name
$rel->{distribution} $rel->{version} by $rel->{author} 
  $rel->{download_url}
  $rel->{status} / $rel->{maturity} (tests: $rel->{tests}{pass}/$rel->{tests}{fail}/$rel->{tests}{unknown}/$rel->{tests}{unknown}  pass/fail/unknown/na)

$rel->{abstract}

EOF
	if ($rel->{provides}) {
		print "Provides:\n";
		print "  - $_\n" for sort @{ $rel->{provides} };
	} else {
		print "Provides: none\n";
	}
	print "\n";
	if ($rel->{dependency}) {
		print "Prereqs:\n";
		for (@{ $rel->{dependency} }) {
			print "  - $_->{phase} $_->{relationship} $_->{module} ($_->{version})\n"
				if  $_->{version};
			print "  - $_->{phase} $_->{relationship} $_->{module}\n"
				if !$_->{version};
		}
	} else {
		print "Prereqs: none\n";
	}
	print "\n";
}

sub deptree
{
	my ($name, $prefix) = @_;
	$prefix ||= '';
	return if $HAVE{$name};
	$HAVE{$name} = 1;

	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";
	my $dist = $rel->{distribution};
	return if $dist =~ m/^perl$/;
	my ($requires ,$build_requires) = deps($rel);

	for (@$build_requires) {
		print "$prefix$name $_->{phase} $_->{relationship} $_->{module}\n";
		deptree($_->{module}, "$prefix  ");
	}
	for (@$requires) {
		print "$prefix$name $_->{phase} $_->{relationship} $_->{module}\n";
		deptree($_->{module}, "$prefix  ");
	}
}

sub arch
{
	my ($name) = @_;
	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";
	my $dist = $rel->{distribution};

	my $url = $rel->{download_url};
	(my $file = $url) =~ s!.*/!!;
	if (! -f "$OPTIONS{root}/SOURCES/$file") {
		step "downloading $url";
		run qq(curl $url > $OPTIONS{root}/SOURCES/$file);
		print "\n";
		$? == 0 or die "Failed.\n";
	}

	my $arch = module_arch("$OPTIONS{root}/SOURCES/$file");
	print "$name is $arch\n";
}

sub build_all
{
	for (@_) {
		my ($mod, $ver);
		if (ref $_) {
			$mod = $_->{module};
			$ver = $_->{version};
		} else {
			$mod = $_;
		}
		build($mod, $ver) unless have_module($mod);
	}
}

sub build
{
	my ($name) = @_;
	die "refusing to build '$name'!\n" if $name =~ m/^perl$/;
	stage "Building $name";

	$SEEN{$name} = 1;
	my $rel = lookup($name)
		or die "Module '$name' not found on CPAN...\n";
	my $dist = $rel->{distribution};
	die "refusing to build '$dist'!\n" if $dist =~ m/^perl$/;
	my ($requires ,$build_requires) = deps($rel);

	for my $dep (@$build_requires) {
		print "   $C{green}$name $dep->{relationship} $dep->{module} (for $dep->{phase})$C{x}\n";
		if (!have_module($dep->{module}, $dep->{version})) {
			die "Module dependency loop detected; I have no idea what to do now...\n"
				if $SEEN{$dep->{module}};

			step "dependent module $dep->{module} needs built";
			build($dep->{module});
		}
	}

	my $specfile = "$OPTIONS{root}/SPECS/$dist.spec";
	my %tokens = specfile($specfile, $rel, $requires, $build_requires);
	step "wrote spec file for $name to $specfile";
	my $arch = module_arch("$OPTIONS{root}/SOURCES/$tokens{SOURCE}");

	step "building RPM package";
	runlog qq(rpmbuild -ba -D "_topdir $OPTIONS{root}" $specfile </dev/null);
	if ($? != 0) {
		if (!check_log(qw/perl\(.*?\) .*is needed by/)) {
			dump_log;
			die "Failed.\n";
		}
		# check the log for perl(...) build deps

		step "building missing build dependencies";
		build_all grep_log(qr/perl\((.*?)\) .*is needed by/);

		# try the build again
		step "retrying RPM package build";
		runlog qq(rpmbuild -ba -D "_topdir $OPTIONS{root}" $specfile </dev/null);
		if ($? != 0) {
			dump_log;
			die "Failed.\n";
		}
		run qq|ls -lh $tokens{RPMFILE}|;
	}

	step "building runtime / installation dependencies";
	build_all @$requires;

	step "installing RPM package";
	runlog qq($SUDO rpm -U RPMS/$arch/$tokens{RPMFILE});
	if ($? != 0) {
		# check the log for perl(...) deps
		unless (check_log(qr/is already installed/)) {
			# build the new deps
			step "building missed dependencies";
			build_all grep_log(qr/perl\((.*?)\) .*is needed by/);

			# try the install again
			step "retrying RPM package installation";
			runlog qq($SUDO rpm -U RPMS/$arch/$tokens{RPMFILE});
			if ($? != 0) {
				dump_log;
				die "Failed\n";
			}
		} else {
			print "... looks like $name is already installed?\n";
			dump_log 'purple';
		}
	}

	print "\n\n";
	$HAVE{$name} = 1;
	delete $SEEN{$name};
}
if (!@ARGV) {
	exit usage();

} elsif ($ARGV[0] eq 'config') {
	printf "%10s: %s\n", $_, $OPTIONS{$_} for sort keys %OPTIONS;

} elsif ($ARGV[0] eq 'spec') {
	shift @ARGV;
	setup;
	spec $_ for @ARGV;

} elsif ($ARGV[0] eq 'source') {
	shift @ARGV;
	setup;
	source $_ for @ARGV;

} elsif ($ARGV[0] eq 'info') {
	shift @ARGV;
	info $_ for @ARGV;

} elsif ($ARGV[0] eq 'dump') {
	shift @ARGV;
	for (@ARGV) {
		my $rel = lookup($_) or next;
		print Dumper($_ => $rel);
		print "\n\n";
	}

} elsif ($ARGV[0] eq 'deptree') {
	shift @ARGV;
	$QUIET = 1;
	deptree $_ for @ARGV;
	print "\n\n";
	print "Total modules: ".scalar(keys %HAVE)."\n";

} elsif ($ARGV[0] eq 'arch') {
	shift @ARGV;
	setup;
	arch $_ for @ARGV;

} elsif ($ARGV[0] eq 'build') {
	shift @ARGV;
	setup;
	build_all 'Module::Runtime'; # my deps
	build_all @ARGV;

} elsif ($ARGV[0]) {
	setup;
	build_all 'Module::Runtime'; # my deps
	build_all @ARGV;

} else {
	print STDERR "USAGE: $0 (spec|source|info|build) Module::Name\n";
	exit 1;
}

__DATA__
Name:           {{RPMPREFIX}}{{DISTNAME}}
Obsoletes:      {{RPMPREFIX}}{{DISTNAME}}
Provides:       {{RPMPREFIX}}{{DISTNAME}}
Version:        {{VERSION}}
Release:        1%{?_dist}
Summary:        {{SUMMARY}}
URL:            {{URL}}
License:        distributable
Group:          Development/Libraries

BuildRoot:      %{_tmppath}/%{name}-root
BuildArch:      {{BUILDARCH}}
Source0:        {{DISTNAME}}-%{version}.tar.gz

{{BUILDREQUIRES}}
{{OVERRIDE_ADD_BUILDREQUIRES}}
{{REQUIRES}}
{{OVERRIDE_ADD_REQUIRES}}

%description
{{DESCRIPTION}}

##########################################################
%prep
%setup -q -n {{ARCHIVE_ROOT}}

%define __perl_provides %{_builddir}/patched-perl-provides
cat > %{__perl_provides} <<'END_PATCHED'
{{PATCHED_PERL_PROVIDES}}
END_PATCHED
chmod +x %{__perl_provides}

%define __new_perl_provides %{_builddir}/cpan-perl-provides
cat > %{__new_perl_provides} <<END_PROVIDES
#!/bin/sh
# drop bad 'Provides' symbols
%{__perl_provides} $* |\
  sed -e 's/\s+$//' |\
{{OVERRIDE_SKIP_PROVIDES}}
  cat
END_PROVIDES
chmod +x %{__new_perl_provides}
%define __perl_provides %{__new_perl_provides}
%define __find_provides %{__new_perl_provides}

%define __new_perl_requires %{_builddir}/cpan-perl-requires
cat > %{__new_perl_requires} <<END_REQUIRES
#!/bin/sh
# drop bad 'Requires' symbols
%{__perl_requires} $* |\
  sed -e 's/\s+$//' |\
{{OVERRIDE_SKIP_REQUIRES}}
  cat
END_REQUIRES
chmod +x %{__new_perl_requires}
%define __perl_requires %{__new_perl_requires}
%define __find_requires %{__new_perl_requires}


##########################################################
%build
if [[ -f Makefile.PL ]]; then
  CFLAGS="$RPM_OPT_FLAGS" perl Makefile.PL INSTALLDIRS=vendor
  make

elif [[ -f Build.PL ]]; then
  CFLAGS="$RPM_OPT_FLAGS" perl Build.PL --installdirs=vendor
  ./Build

else
  echo "Error: No Makefile.PL or Build.PL found!!"
  exit 1

fi


##########################################################
%check
%define __cpanimal_run_tests {{RUN_TESTS}}
%if %{__cpanimal_run_tests}
if [[ -f Makefile.PL ]]; then
  make test

elif [[ -f Build.PL ]]; then
  ./Build test

else
  echo "Error: No Makefile.PL or Build.PL found!!"
  exit 1

fi
%endif


##########################################################
%clean
rm -rf $RPM_BUILD_ROOT


##########################################################
%install
rm -rf $RPM_BUILD_ROOT

if [[ -f Makefile.PL ]]; then
  make install DESTDIR=$RPM_BUILD_ROOT

elif [[ -f Build.PL ]]; then
  ./Build install --destdir=$RPM_BUILD_ROOT

else
  echo "Error: No Makefile.PL or Build.PL found!!"
  exit 1

fi

[ -x /usr/lib/rpm/brp-compress ] && /usr/lib/rpm/brp-compress

{{OVERRIDE_SKIP_FILES}}

find $RPM_BUILD_ROOT \( -name perllocal.pod -o -name .packlist \) -exec rm -v {} \;
find $RPM_BUILD_ROOT/usr -type f -print | \
  sed "s@^$RPM_BUILD_ROOT@@g" > {{DISTNAME}}-%{version}-files

if test ! -s {{DISTNAME}}-%{version}-files; then
  echo "Error: No files found to package!!"
  exit 1
fi

%files -f {{DISTNAME}}-%{version}-files
%defattr(-,root,root)

%changelog
* {{DATE}} {{PACKAGER_NAME}} <{{PACKAGER_EMAIL}}> {{VERSION}}-1
- Initial package, courtesy of cpanimal
__DATA__
#!/usr/bin/perl

# RPM (and it's source code) is covered under two separate licenses.

# The entire code base may be distributed under the terms of the GNU
# General Public License (GPL), which appears immediately below.
# Alternatively, all of the source code in the lib subdirectory of the
# RPM source code distribution as well as any code derived from that
# code may instead be distributed under the GNU Library General Public
# License (LGPL), at the choice of the distributor. The complete text
# of the LGPL appears at the bottom of this file.

# This alternative is allowed to enable applications to be linked
# against the RPM library (commonly called librpm) without forcing
# such applications to be distributed under the GPL.

# Any questions regarding the licensing of RPM should be addressed to
# Erik Troan <ewt@redhat.com>.

# a simple script to print the proper name for perl libraries.

# To save development time I do not parse the perl grammmar but
# instead just lex it looking for what I want.  I take special care to
# ignore comments and pod's.

# it would be much better if perl could tell us the proper name of a
# given script.

# The filenames to scan are either passed on the command line or if
# that is empty they are passed via stdin.

# If there are lines in the file which match the pattern
#      (m/^\s*\$VERSION\s*=\s+/)
# then these are taken to be the version numbers of the modules.
# Special care is taken with a few known idioms for specifying version
# numbers of files under rcs/cvs control.

# If there are strings in the file which match the pattern
#     m/^\s*\$RPM_Provides\s*=\s*["'](.*)['"]/i
# then these are treated as additional names which are provided by the
# file and are printed as well.

# I plan to rewrite this in C so that perl is not required by RPM at
# build time.

# by Ken Estes Mail.com kestes@staff.mail.com
# updated by James Hunt <james@jameshunt.us> for PAUSE shenanigans

if ("@ARGV") {
  foreach (@ARGV) {
    process_file($_);
  }
} else {

  # notice we are passed a list of filenames NOT as common in unix the
  # contents of the file.

  foreach (<>) {
    process_file($_);
  }
}


foreach $module (sort keys %require) {
  if (length($require{$module}) == 0) {
    print "perl($module)\n";
  } else {

    # I am not using rpm3.0 so I do not want spaces arround my
    # operators. Also I will need to change the processing of the
    # $RPM_* variable when I upgrade.

    print "perl($module) = $require{$module}\n";
  }
}

exit 0;



sub process_file {

  my ($file) = @_;
  chomp $file;
  
  open(FILE, "<$file") || return;

  my ($package, $version, $incomment, $inover, $inpause) = ();

  while (<FILE>) {
    
    # skip the documentation

    # we should not need to have item in this if statement (it
    # properly belongs in the over/back section) but people do not
    # read the perldoc.

    if (m/^=(head[1-4]|pod|item)/) {
      $incomment = 1;
    }

    if (m/^=(cut)/) {
      $incomment = 0;
      $inover = 0;
      $inpause = 0;
    }
    
    if (m/^=(over)/) {
      $inover = 1;
    }

    if (m/^=(back)/) {
      $inover = 0;
    }

    if ($incomment || $inover) {
       next;
    }
    
    # skip the data section
    if (m/^__(DATA|END)__$/) {
      last;
    }

    if (m/^\s*package\s*(#.*)?$/) {
      # Some Perl maintainers have taken to writing package decls
      # with a newline and an optional comment, to hide them from
      # the PAUSE (Perl Author Upload SErver) indexer, like so:
      #
      #  package # hide me from PAUSE
      #    Actual::Module::Name;
      $inpause = 1;
      next;
    }

    # not everyone puts the package name of the file as the first
    # package name so we report all namespaces except some common
    # false positives as if they were provided packages (really ugly).

    if (m/^\s*package\s+([_:a-zA-Z0-9]+)\s*;/
        or ($inpause and /\s*([_:a-zA-Z0-9]+)\s*;/)) {
      $package=$1;
      undef $version;
      if ($package eq 'main') {
        undef $package;
      } else {
        # If $package already exists in the $require hash, it means
        # the package definition is broken up over multiple blocks.
        # In that case, don't stomp a previous $VERSION we might have
        # found.  (See BZ#214496.)
        $require{$package}=undef unless (exists $require{$package});
      }
      $inpause = 0;
    }

    # after we found the package name take the first assignment to
    # $VERSION as the version number. Exporter requires that the
    # variable be called VERSION so we are safe.

    # here are examples of VERSION lines from the perl distribution

    #FindBin.pm:$VERSION = $VERSION = sprintf("%d.%02d", q$Revision: 1.9 $ =~ /(\d+)\.(\d+)/);
    #ExtUtils/Install.pm:$VERSION = substr q$Revision: 1.9 $, 10;
    #CGI/Apache.pm:$VERSION = (qw$Revision: 1.9 $)[1];
    #DynaLoader.pm:$VERSION = $VERSION = "1.03";     # avoid typo warning
    #General.pm:$Config::General::VERSION = 2.33;
    # 
    # or with the new "our" pragma you could (read will) see:
    #
    #    our $VERSION = '1.00'
    if (($package) && (m/^\s*(our\s+)?\$(\Q$package\E::)?VERSION\s*=\s+/)) {

      # first see if the version string contains the string
      # '$Revision' this often causes bizzare strings and is the most
      # common method of non static numbering.

      if (m/(\$Revision: (\d+[.0-9]+))/) {
	$version= $2; 
      } elsif (m/[\'\"]?(\d+[.0-9]+)[\'\"]?/) {
	
	# look for a static number hard coded in the script
	
	$version= $1; 
      }
      $require{$package}=$version;
    }
  
    # Allow someone to have a variable that defines virtual packages
    # The variable is called $RPM_Provides.  It must be scoped with 
    # "our", but not "local" or "my" (just would not make sense). 
    # 
    # For instance:
    #  
    #     $RPM_Provides = "blah bleah"
    # 
    # Will generate provides for "blah" and "bleah".
    #
    # Each keyword can appear multiple times.  Don't
    #  bother with datastructures to store these strings,
    #  if we need to print it print it now.
	
    if ( m/^\s*(our\s+)?\$RPM_Provides\s*=\s*["'](.*)['"]/i) {
      foreach $_ (split(/\s+/, $2)) {
	print "$_\n";
      }
    }

  }

  close(FILE) ||
    die("$0: Could not close file: '$file' : $!\n");

  return ;
}
__DATA__
